{"version":3,"file":"index.js","sources":["../src/js/pixabay-api.js","../src/js/render-functions.js","../src/main.js"],"sourcesContent":["'use strict';\n\n// Створюємо константи (змінні):\n// const API_KEY - ключ доступу до API Pixabay. Використовується для ідентифікації запитів, що надсилаються до API, і підтвердження прав доступу.\n// const BASE_URL - базова URL-адреса для доступу (відправлення ззапиту) до Pixabay API, на яку будуть додаватися параметри запиту.\nconst API_KEY = '46843956-48321f6890b82a65cca7319ef';\nconst BASE_URL = 'https://pixabay.com/api/';\n\n// Створюємо функцію (яку будемо експортувати):\n// Функція fetchImages експортується для використання в файлі main.js.\n// Приймає один параметр 'query', що представляє текст запиту, введений користувачем.\nexport function fetchImages(query) {\n  // Оголошуємо змінну searchParams як екземпляр класу URLSearchParams, який полегшує формування рядка параметрів для URL.\n  const searchParams = new URLSearchParams({\n    key: API_KEY, // параметр 'key' - містить ключ API для автентифікації.\n    q: query, // параметр 'q' - запит на пошук, введений користувачем.\n    image_type: 'photo', // тип зображень, які потрібно отримати ('photo').\n    orientation: 'horizontal', // орієнтація зображень - горизонтальні.\n    safesearch: true, // безпечний пошук - виключаємо неприйнятні зображення\n  });\n\n  // Формуємо URL для запиту, використовуючи шаблонні рядки.\n  // Значення 'url' міститиме базовий URL Pixabay API, до якого додаються параметри запиту з об'єкта 'searchParams'.\n  const url = `${BASE_URL}?${searchParams}`;\n\n  // Створюємо і повертаємо метод fetch:\n  // Виконуємо HTTP-запит до сформованого URL за допомогою методу fetch, який повертає проміс.\n  return (\n    fetch(url)\n      // // Обробляємо отриману відповідь у методі 'then', який викликається після завершення запиту.\n      // Перший then повертає проміс, який, в свою чергу, буде вирішено значенням, що повертається з response.json()\n      // // Параметр 'response' - це об'єкт відповіді, отриманий від методу fetch і він містить інформацію про відповідь від сервера.\n      .then(response => {\n        // Перевіряємо властивість 'ok' об'єкта 'response'.\n        // Властивість 'ok' є булевою і вказує на успішність запиту:\n        // - true, якщо статус відповіді від 200 до 299 (успішні відповіді)\n        // - false в іншому випадку.\n        if (!response.ok) {\n          // Якщо 'ok' є false, викидаємо новий екземпляр помилки з відповідним повідомленням.\n          throw new Error('Network response was not ok');\n        }\n        // якщо 'response.ok' є true, викликаємо метод 'json()' для перетворення відповіді в формат JSON і повертаємо його (повертає проміс).\n        return response.json();\n      })\n      // Другий метод 'then', який обробляє результат першого 'then'.\n      // Параметр 'data' містить значення, отримане з попереднього промісу (JSON-об'єкт, який був повернутий з response.json()).\n      // Якщо в response.json() немає помилок, то data міститиме об'єкт (або масив об'єктів), отриманий з API.\n      .then(data => {\n        // Повертаємо отримані дані для подальшого використання.\n        return data;\n      })\n      // Обробка помилок з використанням методу catch:\n      // Метод 'catch' обробляє помилки, які виникають у ланцюзі промісів.\n      // Параметр 'error' містить інформацію про помилку, яка сталася під час виконання запиту.\n      //\n      .catch(error => {\n        // Використовуємо бібліотеку iziToast для виводу повідомлення про помилку.\n        iziToast.error({\n          title: 'Error', // Заголовок повідомлення.\n          message: 'Failed to fetch images. Please try again later.', // Текст повідомлення, що інформує користувача про невдалий запит.\n          position: 'topRight', // Розташування повідомлення на екрані.\n        });\n        // Виводимо деталі помилки у консоль для розробників.\n        console.error('There was a problem with the fetch operation:', error);\n      })\n  );\n}\n\n// !!!***!!! результат ПЕРШОГО then - це ПРОМІС, який при успішному виконанні надає data (JSON-дані) для ДРУГОГО then.!!!\n","'use strict';\n\n// Оголошуємо змінну 'gallery' та отримуємо доступ до DOM-елемента з класом 'gallery'.\n// Цей елемент буде використовуватися для динамічного відображення зображень у вигляді списку <ul class=\"gallery\"></ul>.\nconst gallery = document.querySelector('.gallery');\n\n// Створюємо функцію 'createMarkup', яку можна експортувати з модуля.\n// Функція приймає один параметр 'arrImages' (data.hits в файлі main.js), який є масивом об'єктів з інформацією про зображення.\n// Функція 'createMarkup' буде імпортуватись і використовуватись в файлі main.js\nexport function createMarkup(arrImages) {\n  // Оголошуємо змінну 'markup', в якій будемо зберігати згенеровану HTML-розмітку.\n  const markup = arrImages\n    // Використовуємо метод 'map' для перебору масиву об'єктів 'arrImages'.\n    // 'image' є параметром колбека, що представляє кожен об'єкт з масиву.\n    .map(image => {\n      // Створюємо і повертаємо HTML-розмітку.\n      // В шаблонних рядках використовуємо властивості об'єкта image\n      return `<li class=\"gallery-item\">\n\t  <a class=\"gallery-link\" href=\"${image.largeImageURL}\">\n\t\t<img \n\t\t\tclass=\"gallery-image\" \n\t\t\tsrc=\"${image.webformatURL}\" \n\t\t\talt=\"${image.tags}\" \n\t\t\t/>\n        <div class=\"gallery-info\">\n        <p class=\"gallery-likes\"><span>Likes:</span> ${image.likes}</p>\n        <p class=\"gallery-views\"><span>Views:</span> ${image.views}</p>\n        <p class=\"gallery-comments\"><span>Comments:</span> ${image.comments}</p>\n        <p class=\"gallery-downloads\"><span>Downloads:</span> ${image.downloads}</p>\n      </div>    \n\t  </a>\n    </li>\n    `;\n    })\n    // // Об'єднуємо масив рядків в один рядок HTML (метод join()), щоб його можна було вставити в DOM.\n    .join('');\n\n  // Очищення наповнення галереї видаляючи всі наявні елементи списку <ul class=\"gallery\"></ul>.\n  gallery.innerHTML = '';\n\n  // Вставляємо сформовану HTML-розмітку (яка зберігається у змінній markup) на початок (всередину) елемента <ul class=\"gallery\">\n  gallery.insertAdjacentHTML('afterbegin', markup);\n}\n","'use strict';\n\n// Ми імпортуємо бібліотеку iziToast та стилі для відображення повідомлень.\nimport iziToast from 'izitoast';\nimport 'izitoast/dist/css/iziToast.min.css';\n\n// Ми імпортуємо SimpleLightbox для відображення зображень у збільшеному вигляді при кліку. simple-lightbox.min.css додає стилі для цього інтерфейсу.\nimport SimpleLightbox from 'simplelightbox';\nimport 'simplelightbox/dist/simple-lightbox.min.css';\n\n// Імпортуємо функцію fetchImages з файлу pixabay-api.js, яка виконує запит до API Pixabay і повертає зображення, що відповідають пошуковому запиту.\nimport { fetchImages } from './js/pixabay-api';\n\n// Імпортуємо функцію createMarkup з файлу render-functions.js, яка динамічно генерує HTML-розмітку для галереї зображень.\nimport { createMarkup } from './js/render-functions';\n\n// Оголошуємо змінну lightbox, яка буде використовуватись для ініціалізації та оновлення інтерфейсу SimpleLightbox. Це дозволяє зберігати стан lightbox і оновлювати галерею після кожного нового пошуку.\nlet lightbox;\n\nconst gallery = document.querySelector('.gallery');\n// Знаходимо HTML-елемент форми, щоб додати обробник події для пошуку зображень.\nconst form = document.querySelector('.form');\n\n// Знаходимо поле вводу, щоб отримати текст пошукового запиту від користувача.\nconst input = document.querySelector('.input');\n\n// Знаходимо елемент лоадера, щоб керувати його відображенням під час завантаження зображень.\nconst loader = document.querySelector('.loader');\n\n// Ми додаємо обробник події submit до форми. Це означає, що коли користувач натискає кнопку \"Search\" або натискає Enter у полі вводу, викликається функція handleSubmit. Ця функція обробляє пошуковий запит.\nform.addEventListener('submit', handleSubmit);\n\n// Створюємо функцію-обробник handleSubmit з параметром event (об'єкт події). Цей об'єкт містить інформацію про подію, що відбулася, і дозволяє нам керувати поведінкою форми\nfunction handleSubmit(event) {\n  // Скасовуємо стандартну поведінку форми (при відправці форми), без перезавантаження сторінки\n  event.preventDefault();\n\n  // Створюємо змінну query, у яку записуємо текст з поля вводу, попередньо обрізавши зайві пробіли на початку і в кінці (метод .trim()).\n  const query = input.value.trim();\n\n  // Перевірка на порожній запит і показ помилки з iziToast\n  // Якщо значення query є порожнім (тобто поле вводу пусте або містить тільки пробіли), ми показуємо повідомлення про помилку і припиняємо подальше виконання функції.\n  // Використовуємо бібліотеку iziToast для відображення повідомлення про помилку.\n  if (!query) {\n    iziToast.error({\n      title: 'Error',\n      message: 'Please enter a search query...',\n      position: 'topRight',\n    });\n    return;\n  }\n\n  // Показуємо лоадер перед початком запиту: Встановлюємо значення CSS-властивості display для елемента з класом .loader (<span class=\"loader\"></span>) на block, що робить його видимим на сторінці. Це потрібно, щоб показати користувачеві індикатор завантаження під час запиту.\n  loader.style.display = 'block';\n\n  // Викликаємо функцію fetchImages і обробляємо отримані дані\n  // fetchImages(query) — Викликаємо функцію fetchImages, передаючи їй query, тобто значення пошукового запиту, яке ми попередньо валідували. fetchImages повертає проміс, який буде вирішений після завершення запиту до API.\n  fetchImages(query)\n    // .then(data => {...}) — Використовуємо метод .then для обробки результату виконання проміса. Коли запит завершується успішно, проміс передає об'єкт data — це відповідь від API, що містить інформацію про знайдені зображення.\n    // в data буде знаходитись об'єкт*** (пояснення нижче), отриманий у відповідь від API після успішного виконання проміса. У цьому об'єкті data будуть ключі та значення, які відповідають структурі відповіді від API Pixabay.\n    .then(data => {\n      // loader.style.display = 'none'; — Після отримання даних від API, змінюємо значення CSS-властивості display на none, щоб приховати елемент .loader з екрану, оскільки завантаження завершено.\n      loader.style.display = 'none';\n\n      // Перевірка на наявність результатів:\n      // Перевіряємо, чи масив зображень data.hits порожній, використовуючи умову if. Якшо масив порожній - тобто зображень за запитом не знайдено, очищюємо наповнення галереї видаляючи всі наявні елементи списку <ul class=\"gallery\"></ul> і виводимо повідомлення за допомогою iziToast.info() з текстом про відсутність результатів.\n      if (data.hits.length === 0) {\n        gallery.innerHTML = '';\n        iziToast.info({\n          title: 'No Results',\n          message:\n            'Sorry, there are no images matching your search query. Please try again!',\n          position: 'topRight',\n          timeout: 5000,\n        });\n\n        // Скидаємо форму, щоб очистити введене значення (form.reset())\n        form.reset();\n\n        // припиняємо подальше виконання функції, оскільки немає зображень для відображення\n        return;\n      }\n\n      // Відображення результатів у галереї: функція створить і додасть розмітку з результатами в галерею, забезпечуючи відображення знайдених зображень для користувача.\n      // Викликаємо функцію createMarkup() (яку імпортували з ./js/render-functions) і передаємо в неї масив зображень data.hits\n      createMarkup(data.hits);\n\n      // Налаштування та оновлення галереї зображень за допомогою SimpleLightbox\n      // Перевірка екземпляра lightbox (створили раніше let lightbox)\n      // Виконуємо перевірку if (lightbox), щоб визначити, чи вже існує екземпляр lightbox.\n      // Якщо екземпляр вже існує (true), викликаємо метод refresh() для оновлення (ніби очищення кешу бібліотеки , щоб включити нові зображення в галерею після додавання результатів пошуку\n      // Якщо екземпляр ще не існує, виконується блок else. У блоці else створюємо новий екземпляр SimpleLightbox з ініціалізацією на елементи посилань у \".gallery a\"\n      // Додаємо об'єкт з налаштуваннями\n      if (lightbox) {\n        lightbox.refresh();\n      } else {\n        lightbox = new SimpleLightbox('.gallery a', {\n          captions: true, // включає відображення підписів до зображень\n          captionSelector: 'img', // Вказуємо, що підпис прив'язаний до зображень (<img>)\n          captionType: 'attr', // Вибираємо тип джерела підпису - атрибут\n          captionsData: 'alt', // Вказуємо, що текст підпису береться з атрибута alt\n          captionDelay: 250, // задає затримку перед відображенням підпису\n        });\n      }\n    })\n\n    // .catch(error => {...}) - Обробляємо помилку, якщо проміс, отриманий від функції fetchImages, завершується з помилкою.\n    // Викликається метод .catch(), який приймає колбек-функцію, що виконується лише у випадку, коли запит на зображення не завершився успішно (наприклад, через мережеву помилку або проблему з API).\n    // Перш за все, приховуємо <span class=\"loader\"></span>, щоб зупинити анімацію завантаження лоадера, встановлюючи йому CSS-властивість display = 'none'. Це забезпечує зникнення індикатора завантаження, навіть якщо запит не був успішним\n    .catch(error => {\n      loader.style.display = 'none'; // Приховуємо лоадер у разі помилки\n      console.error(error); // Виводимо помилку в консоль для налагодження\n    });\n}\n\n/// *** В data буде знаходитись об'єкт, отриманий у відповідь від API після успішного виконання проміса. У цьому об'єкті data будуть ключі та значення, які відповідають структурі відповіді від API Pixabay.\n\n// Зокрема, коли ми надсилаємо запит до Pixabay API, у відповіді приходить об'єкт, який містить такі основні поля:\n\n// total — загальна кількість зображень, що відповідають запиту.\n// totalHits — кількість зображень, що повернені для даної сторінки.\n// hits — масив об'єктів, кожен з яких представляє окреме зображення. Кожен об'єкт у масиві hits має різні властивості, такі як:\n// webformatURL — URL зображення в середній якості.\n// largeImageURL — URL зображення у високій якості.\n// tags — ключові слова для зображення.\n// likes, views, comments, downloads — метрики, які показують популярність зображення.\n// Отже, data.hits буде масивом об'єктів з інформацією про зображення, який ми використовуємо для створення динамічної галереї.\n\n// **** Детальніше про перевірку екземпляру lightbox:\n\n// Перевіряємо, чи змінна lightbox вже містить екземпляр класу SimpleLightbox.\n// Якщо об'єкт lightbox існує (його значення не є null чи undefined), це означає,\n// що ми вже ініціалізували SimpleLightbox раніше. У такому разі викликаємо метод\n// refresh(), щоб \"перезавантажити\" бібліотеку: цей метод оновлює посилання на зображення,\n// доступні у lightbox, включаючи нові зображення, отримані після останнього пошуку.\n// Це дозволяє SimpleLightbox переглядати зображення від поточного запиту користувача.\n// -------------------------------------------------------------------------\n// Якщо ж об'єкт lightbox ще не створений (тобто значення lightbox є falsy, наприклад,\n// null або undefined), то ми ініціалізуємо його, створюючи новий екземпляр класу SimpleLightbox,\n// і прикріплюємо його до всіх елементів <a> всередині контейнера з класом .gallery.\n// Ми також передаємо налаштування у вигляді об'єкта як другий аргумент, щоб налаштувати\n// підписи до зображень і затримку перед їхнім відображенням.\n"],"names":["API_KEY","BASE_URL","fetchImages","query","searchParams","url","response","data","error","gallery","createMarkup","arrImages","markup","image","lightbox","form","input","loader","handleSubmit","event","iziToast","SimpleLightbox"],"mappings":"iyBAKA,MAAMA,EAAU,qCACVC,EAAW,2BAKV,SAASC,EAAYC,EAAO,CAEjC,MAAMC,EAAe,IAAI,gBAAgB,CACvC,IAAKJ,EACL,EAAGG,EACH,WAAY,QACZ,YAAa,aACb,WAAY,EAChB,CAAG,EAIKE,EAAM,GAAGJ,CAAQ,IAAIG,CAAY,GAIvC,OACE,MAAMC,CAAG,EAIN,KAAKC,GAAY,CAKhB,GAAI,CAACA,EAAS,GAEZ,MAAM,IAAI,MAAM,6BAA6B,EAG/C,OAAOA,EAAS,MACxB,CAAO,EAIA,KAAKC,GAEGA,CACR,EAKA,MAAMC,GAAS,CAEd,SAAS,MAAM,CACb,MAAO,QACP,QAAS,kDACT,SAAU,UACpB,CAAS,EAED,QAAQ,MAAM,gDAAiDA,CAAK,CAC5E,CAAO,CAEP,CC9DA,MAAMC,EAAU,SAAS,cAAc,UAAU,EAK1C,SAASC,EAAaC,EAAW,CAEtC,MAAMC,EAASD,EAGZ,IAAIE,GAGI;AAAA,mCACsBA,EAAM,aAAa;AAAA;AAAA;AAAA,UAG5CA,EAAM,YAAY;AAAA,UAClBA,EAAM,IAAI;AAAA;AAAA;AAAA,uDAGmCA,EAAM,KAAK;AAAA,uDACXA,EAAM,KAAK;AAAA,6DACLA,EAAM,QAAQ;AAAA,+DACZA,EAAM,SAAS;AAAA;AAAA;AAAA;AAAA,KAKzE,EAEA,KAAK,EAAE,EAGVJ,EAAQ,UAAY,GAGpBA,EAAQ,mBAAmB,aAAcG,CAAM,CACjD,CCzBA,IAAIE,EAEJ,MAAML,EAAU,SAAS,cAAc,UAAU,EAE3CM,EAAO,SAAS,cAAc,OAAO,EAGrCC,EAAQ,SAAS,cAAc,QAAQ,EAGvCC,EAAS,SAAS,cAAc,SAAS,EAG/CF,EAAK,iBAAiB,SAAUG,CAAY,EAG5C,SAASA,EAAaC,EAAO,CAE3BA,EAAM,eAAc,EAGpB,MAAMhB,EAAQa,EAAM,MAAM,KAAI,EAK9B,GAAI,CAACb,EAAO,CACViB,EAAS,MAAM,CACb,MAAO,QACP,QAAS,iCACT,SAAU,UAChB,CAAK,EACD,MACD,CAGDH,EAAO,MAAM,QAAU,QAIvBf,EAAYC,CAAK,EAGd,KAAKI,GAAQ,CAMZ,GAJAU,EAAO,MAAM,QAAU,OAInBV,EAAK,KAAK,SAAW,EAAG,CAC1BE,EAAQ,UAAY,GACpBW,EAAS,KAAK,CACZ,MAAO,aACP,QACE,2EACF,SAAU,WACV,QAAS,GACnB,CAAS,EAGDL,EAAK,MAAK,EAGV,MACD,CAIDL,EAAaH,EAAK,IAAI,EAQlBO,EACFA,EAAS,QAAO,EAEhBA,EAAW,IAAIO,EAAe,aAAc,CAC1C,SAAU,GACV,gBAAiB,MACjB,YAAa,OACb,aAAc,MACd,aAAc,GACxB,CAAS,CAET,CAAK,EAKA,MAAMb,GAAS,CACdS,EAAO,MAAM,QAAU,OACvB,QAAQ,MAAMT,CAAK,CACzB,CAAK,CACL"}