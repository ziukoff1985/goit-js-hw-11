'use strict';

// Ми імпортуємо бібліотеку iziToast та стилі для відображення повідомлень.
import iziToast from 'izitoast';
import 'izitoast/dist/css/iziToast.min.css';

// Ми імпортуємо SimpleLightbox для відображення зображень у збільшеному вигляді при кліку. simple-lightbox.min.css додає стилі для цього інтерфейсу.
import SimpleLightbox from 'simplelightbox';
import 'simplelightbox/dist/simple-lightbox.min.css';

// Імпортуємо функцію fetchImages з файлу pixabay-api.js, яка виконує запит до API Pixabay і повертає зображення, що відповідають пошуковому запиту.
import { fetchImages } from './js/pixabay-api';

// Імпортуємо функцію createMarkup з файлу render-functions.js, яка динамічно генерує HTML-розмітку для галереї зображень.
import { createMarkup } from './js/render-functions';

// Оголошуємо змінну lightbox, яка буде використовуватись для ініціалізації та оновлення інтерфейсу SimpleLightbox. Це дозволяє зберігати стан lightbox і оновлювати галерею після кожного нового пошуку.
let lightbox;

const gallery = document.querySelector('.gallery');
// Знаходимо HTML-елемент форми, щоб додати обробник події для пошуку зображень.
const form = document.querySelector('.form');

// Знаходимо поле вводу, щоб отримати текст пошукового запиту від користувача.
const input = document.querySelector('.input');

// Знаходимо елемент лоадера, щоб керувати його відображенням під час завантаження зображень.
const loader = document.querySelector('.loader');

// Ми додаємо обробник події submit до форми. Це означає, що коли користувач натискає кнопку "Search" або натискає Enter у полі вводу, викликається функція handleSubmit. Ця функція обробляє пошуковий запит.
form.addEventListener('submit', handleSubmit);

// Створюємо функцію-обробник handleSubmit з параметром event (об'єкт події). Цей об'єкт містить інформацію про подію, що відбулася, і дозволяє нам керувати поведінкою форми
function handleSubmit(event) {
  // Скасовуємо стандартну поведінку форми (при відправці форми), без перезавантаження сторінки
  event.preventDefault();

  // Створюємо змінну query, у яку записуємо текст з поля вводу, попередньо обрізавши зайві пробіли на початку і в кінці (метод .trim()).
  const query = input.value.trim();

  // Перевірка на порожній запит і показ помилки з iziToast
  // Якщо значення query є порожнім (тобто поле вводу пусте або містить тільки пробіли), ми показуємо повідомлення про помилку і припиняємо подальше виконання функції.
  // Використовуємо бібліотеку iziToast для відображення повідомлення про помилку.
  if (!query) {
    iziToast.error({
      title: 'Error',
      message: 'Please enter a search query...',
      position: 'topRight',
    });
    return;
  }

  // Показуємо лоадер перед початком запиту: Встановлюємо значення CSS-властивості display для елемента з класом .loader (<span class="loader"></span>) на block, що робить його видимим на сторінці. Це потрібно, щоб показати користувачеві індикатор завантаження під час запиту.
  loader.style.display = 'block';

  // Викликаємо функцію fetchImages і обробляємо отримані дані
  // fetchImages(query) — Викликаємо функцію fetchImages, передаючи їй query, тобто значення пошукового запиту, яке ми попередньо валідували. fetchImages повертає проміс, який буде вирішений після завершення запиту до API.
  fetchImages(query)
    // .then(data => {...}) — Використовуємо метод .then для обробки результату виконання проміса. Коли запит завершується успішно, проміс передає об'єкт data — це відповідь від API, що містить інформацію про знайдені зображення.
    // в data буде знаходитись об'єкт*** (пояснення нижче), отриманий у відповідь від API після успішного виконання проміса. У цьому об'єкті data будуть ключі та значення, які відповідають структурі відповіді від API Pixabay.
    .then(data => {
      // loader.style.display = 'none'; — Після отримання даних від API, змінюємо значення CSS-властивості display на none, щоб приховати елемент .loader з екрану, оскільки завантаження завершено.
      loader.style.display = 'none';

      // Перевірка на наявність результатів:
      // Перевіряємо, чи масив зображень data.hits порожній, використовуючи умову if. Якшо масив порожній - тобто зображень за запитом не знайдено, очищюємо наповнення галереї видаляючи всі наявні елементи списку <ul class="gallery"></ul> і виводимо повідомлення за допомогою iziToast.info() з текстом про відсутність результатів.
      if (data.hits.length === 0) {
        gallery.innerHTML = '';
        iziToast.info({
          title: 'No Results',
          message:
            'Sorry, there are no images matching your search query. Please try again!',
          position: 'topRight',
          timeout: 5000,
        });

        // Скидаємо форму, щоб очистити введене значення (form.reset())
        form.reset();

        // припиняємо подальше виконання функції, оскільки немає зображень для відображення
        return;
      }

      // Відображення результатів у галереї: функція створить і додасть розмітку з результатами в галерею, забезпечуючи відображення знайдених зображень для користувача.
      // Викликаємо функцію createMarkup() (яку імпортували з ./js/render-functions) і передаємо в неї масив зображень data.hits
      createMarkup(data.hits);

      // Налаштування та оновлення галереї зображень за допомогою SimpleLightbox
      // Перевірка екземпляра lightbox (створили раніше let lightbox)
      // Виконуємо перевірку if (lightbox), щоб визначити, чи вже існує екземпляр lightbox.
      // Якщо екземпляр вже існує (true), викликаємо метод refresh() для оновлення (ніби очищення кешу бібліотеки , щоб включити нові зображення в галерею після додавання результатів пошуку
      // Якщо екземпляр ще не існує, виконується блок else. У блоці else створюємо новий екземпляр SimpleLightbox з ініціалізацією на елементи посилань у ".gallery a"
      // Додаємо об'єкт з налаштуваннями
      if (lightbox) {
        lightbox.refresh();
      } else {
        lightbox = new SimpleLightbox('.gallery a', {
          captions: true, // включає відображення підписів до зображень
          captionSelector: 'img', // Вказуємо, що підпис прив'язаний до зображень (<img>)
          captionType: 'attr', // Вибираємо тип джерела підпису - атрибут
          captionsData: 'alt', // Вказуємо, що текст підпису береться з атрибута alt
          captionDelay: 250, // задає затримку перед відображенням підпису
        });
      }
    })

    // .catch(error => {...}) - Обробляємо помилку, якщо проміс, отриманий від функції fetchImages, завершується з помилкою.
    // Викликається метод .catch(), який приймає колбек-функцію, що виконується лише у випадку, коли запит на зображення не завершився успішно (наприклад, через мережеву помилку або проблему з API).
    // Перш за все, приховуємо <span class="loader"></span>, щоб зупинити анімацію завантаження лоадера, встановлюючи йому CSS-властивість display = 'none'. Це забезпечує зникнення індикатора завантаження, навіть якщо запит не був успішним
    .catch(error => {
      loader.style.display = 'none'; // Приховуємо лоадер у разі помилки
      console.error(error); // Виводимо помилку в консоль для налагодження
    });
}

/// *** В data буде знаходитись об'єкт, отриманий у відповідь від API після успішного виконання проміса. У цьому об'єкті data будуть ключі та значення, які відповідають структурі відповіді від API Pixabay.

// Зокрема, коли ми надсилаємо запит до Pixabay API, у відповіді приходить об'єкт, який містить такі основні поля:

// total — загальна кількість зображень, що відповідають запиту.
// totalHits — кількість зображень, що повернені для даної сторінки.
// hits — масив об'єктів, кожен з яких представляє окреме зображення. Кожен об'єкт у масиві hits має різні властивості, такі як:
// webformatURL — URL зображення в середній якості.
// largeImageURL — URL зображення у високій якості.
// tags — ключові слова для зображення.
// likes, views, comments, downloads — метрики, які показують популярність зображення.
// Отже, data.hits буде масивом об'єктів з інформацією про зображення, який ми використовуємо для створення динамічної галереї.

// **** Детальніше про перевірку екземпляру lightbox:

// Перевіряємо, чи змінна lightbox вже містить екземпляр класу SimpleLightbox.
// Якщо об'єкт lightbox існує (його значення не є null чи undefined), це означає,
// що ми вже ініціалізували SimpleLightbox раніше. У такому разі викликаємо метод
// refresh(), щоб "перезавантажити" бібліотеку: цей метод оновлює посилання на зображення,
// доступні у lightbox, включаючи нові зображення, отримані після останнього пошуку.
// Це дозволяє SimpleLightbox переглядати зображення від поточного запиту користувача.
// -------------------------------------------------------------------------
// Якщо ж об'єкт lightbox ще не створений (тобто значення lightbox є falsy, наприклад,
// null або undefined), то ми ініціалізуємо його, створюючи новий екземпляр класу SimpleLightbox,
// і прикріплюємо його до всіх елементів <a> всередині контейнера з класом .gallery.
// Ми також передаємо налаштування у вигляді об'єкта як другий аргумент, щоб налаштувати
// підписи до зображень і затримку перед їхнім відображенням.
